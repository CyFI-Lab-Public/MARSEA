///
/// Copyright (C) 2018, Adrian Herrera
/// All rights reserved.
///

#include <stdio.h>
#include <string.h>

#include <Shlwapi.h>
#include <Windows.h>

#include <easyhook.h>

// We must add this header file to support writing to S2E's logs. s2e.h resides
// in the libcommon project, so the libcommon project must be added as a
// dependency to the malware-inject project
#define USER_APP
#include <s2e/s2e.h>
/// Maximum message length to write to S2E debug log
#define S2E_MSG_LEN 512

/// Maximum path length
#define MAX_PATH_LEN 256

/// S2E version number, or 0 if not running in S2E mode
static INT s2eVersion = 0;

///
/// Write a message to the S2E log (or stdout).
///
static void Message(LPCSTR fmt, ...) {
    CHAR message[S2E_MSG_LEN];
    va_list args;

    va_start(args, fmt);
    vsnprintf(message, S2E_MSG_LEN, fmt, args);
    va_end(args);

    if (s2eVersion) {
        S2EMessageFmt("[malware-inject] %s", message);
    }
    else {
        printf("[malware-inject] %s", message);
    }
}

///
/// Checks that the given \c path is valid and if so returns the full path in
/// \c fullPath. Otherwise the program exits with an error.
///
static void GetFullPath(LPCWSTR path, PWCHAR fullPath) {
    if (!path) {
        Message("Path has not been provided\n");
        exit(1);
    }

    if (!PathFileExistsW(path)) {
        Message("Invalid path %S has been provided\n", path);
        exit(1);
    }

    if (!GetFullPathNameW(path, MAX_PATH_LEN, fullPath, NULL)) {
        Message("Unable to get full path of %S\n", path);
        exit(1);
    }
}

int main() {
    INT argc;
    LPWSTR *argv = CommandLineToArgvW(GetCommandLineW(), &argc);

    if (argc < 5) {
        printf("Usage: %S [options..]\n"
            "   --dll <dll>       Path to DLL to inject into the application\n"
            "   --app <target>    Path to application to start\n"
            "   --timeout <time>  Timeout value in milliseconds "
            "(infinite if not provided)\n", argv[0]);
        exit(1);
    }

    // Used by the Message function to decide where to write output to
    s2eVersion = S2EGetVersion();

    LPWSTR dllPath = NULL;
    WCHAR fullDllPath[MAX_PATH_LEN];

    LPWSTR appPath = NULL;
    WCHAR fullAppPath[MAX_PATH_LEN];

    DWORD timeout = INFINITE;

    for (int i = 1; i < argc; ++i) {
        if (wcscmp(argv[i], L"--dll") == 0) {
            dllPath = argv[++i];
            continue;
        }

        if (wcscmp(argv[i], L"--app") == 0) {
            appPath = argv[++i];
            continue;
        }

        if (wcscmp(argv[i], L"--timeout") == 0) {
            timeout = wcstoul(argv[++i], NULL, 10);
            continue;
        }

        Message("Unsupported argument: %s\n", argv[i]);
        exit(1);
    }

    // Check that the given paths are valid and get their full paths
    GetFullPath(dllPath, fullDllPath);
    GetFullPath(appPath, fullAppPath);

    WCHAR progargs[16] = L"-st\0\0\0\0\0\0\0\0\0\0\0\0";
    S2EMakeSymbolic(progargs, sizeof(WCHAR) * 15, "ProgArgs");

    // NOTE(barua): This is a hack to wait for a tree of processes created by
    // the malware process that it doesn't terminate before exiting itself.
    //
    // The general idea -
    // 
    // 1. Create a job object (job)
    // 2. Create an IO completion port (io_port)
    // 3. Associate the job object with the IO completion port
    //    - Set the completion "key" to the job object itself, to avoid
    //      confusion
    // 4. Create the malware process in a suspended state
    // 5. Assign the malware process to the job object
    // 6. Inject the target DLL
    // 7. Wait for the child processes to terminate - Loop and wait till we get
    //    a message that basically says "this job object has no more active
    //    processes"
    HANDLE job = CreateJobObject(NULL, NULL);
    if (!job) {
        Message("CreateJobObject error: %d\n", GetLastError());
        exit(1);
    }
    Message("Created Job Object");

    HANDLE io_port = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
    if (!io_port) {
        Message("CreateIoCompletionPort error: %d\n", GetLastError());
        exit(1);
    }
    Message("Created IO Completion Port");

    JOBOBJECT_ASSOCIATE_COMPLETION_PORT port;
    port.CompletionKey = job;
    port.CompletionPort = io_port;
    if (!SetInformationJobObject(job, JobObjectAssociateCompletionPortInformation, &port, sizeof(port))) {
        Message("SetInformationJobObject error: %d\n", GetLastError());
        exit(1);
    }

    PROCESS_INFORMATION process_information;
    STARTUPINFO startup_info = { sizeof(startup_info) };
    if (!CreateProcess(fullAppPath, progargs, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &startup_info, &process_information)) {
        Message("CreateProcess error: %d\n", GetLastError());
        exit(1);
    }
    Message("Spawned child process in suspended state");

    if (!AssignProcessToJobObject(job, process_information.hProcess)) {
        Message("AssignProcessToJobObject error: %d\n", GetLastError());
        exit(1);
    }
    Message("Assigned child process to job");

    NTSTATUS result = RhInjectLibrary(process_information.dwProcessId,
        process_information.dwThreadId, EASYHOOK_INJECT_DEFAULT,
#if defined(_M_IX86)
        dllPath, NULL,
#elif defined(_M_X64)
        NULL, dllPath,
#else
#error "Platform not supported"
#endif
        NULL, 0);
    if (FAILED(result)) {
        Message("RhInjectLibrary failed: %S\n", RtlGetLastErrorString());
        exit(1);
    }
    Message("Successfully injected %S into %S (PID=0x%x)\n", fullDllPath,
        fullAppPath, process_information.dwProcessId);

    CloseHandle(process_information.hThread);
    CloseHandle(process_information.hProcess);

    DWORD completion_code;
    ULONG_PTR completion_key;
    LPOVERLAPPED overlapped;
    BOOL res;
    while ((res = GetQueuedCompletionStatus(io_port, &completion_code, &completion_key, &overlapped, INFINITE))) {
        if ((HANDLE)completion_key == job) {
            Message("Received completion status for job");
            switch (completion_code) {
            case JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS:
                Message("JobObject: Abnormal exit process: 0x%x", overlapped);
                break;
            case JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT:
                Message("JobObject: Active process limit exceeded");
                break;
            case JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO:
                Message("JobObject: == No more processes in job == ... All done!");
                return 0;
            case JOB_OBJECT_MSG_END_OF_JOB_TIME:
                Message("JobObject: ERROR: End of job time");
                break;
            case JOB_OBJECT_MSG_END_OF_PROCESS_TIME:
                Message("JobObject: End of process time: 0x%x", overlapped);
                break;
            case JOB_OBJECT_MSG_EXIT_PROCESS:
                Message("JobObject: Process exited: 0x%x", overlapped);
                break;
            case JOB_OBJECT_MSG_JOB_MEMORY_LIMIT:
                Message("JobObject: ERROR: Job memory limit exceeded");
                break;
            case JOB_OBJECT_MSG_NEW_PROCESS:
                Message("JobObject: New process: 0x%x", overlapped);
                break;
            case JOB_OBJECT_MSG_NOTIFICATION_LIMIT:
                Message("JobObject: Process exceeded resource limit notification: 0x%x", overlapped);
                break;
            case JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT:
                Message("JobObject: Process exceeded memory limit: 0x%x", overlapped);
                break;
            default:
                Message("JobObject: Unknown");
            }
        }
        Message("Still waiting ...\n");
    }
    if (!res) {
        Message("GetQueuedCompletionStatus error: %d\n", GetLastError());
    }
    Message("All done\n");

    return 0;
}
