///
/// Copyright (C) 2010-2016, Dependable Systems Laboratory, EPFL
/// Copyright (C) 2014-2019, Cyberhaven
/// All rights reserved.
///
/// Licensed under the Cyberhaven Research License Agreement.
///

#include <llvm/ExecutionEngine/ExecutionEngine.h>
#include <llvm/ExecutionEngine/GenericValue.h>

#include <s2e/S2EExecutor.h>
#include <s2e/S2EExternalDispatcher.h>
#include <s2e/Utils.h>
#include <s2e/cpu.h>
#include <s2e/s2e_config.h>

using namespace llvm;

namespace s2e {

jmp_buf S2EExternalDispatcher::s2e_cpuExitJmpBuf;
jmp_buf S2EExternalDispatcher::s2e_escapeCallJmpBuf;

void S2EExternalDispatcher::s2e_ext_sigsegv_handler(int signal, siginfo_t *info, void *context) {
    longjmp(s2e_escapeCallJmpBuf, 1);
}

void S2EExternalDispatcher::saveJmpBuf() {
    memcpy(s2e_cpuExitJmpBuf, env->jmp_env, sizeof(env->jmp_env));
}

void S2EExternalDispatcher::restoreJmpBuf() {
    memcpy(env->jmp_env, s2e_cpuExitJmpBuf, sizeof(env->jmp_env));
}

bool S2EExternalDispatcher::runProtectedCall(Function *f, uint64_t *args) {
    bool res;

    if (!f) {
        return false;
    }

    gTheArgsP = args;

    struct sigaction segvAction, segvActionOld;
    segvAction.sa_handler = 0;
    memset(&segvAction.sa_mask, 0, sizeof(segvAction.sa_mask));
    segvAction.sa_flags = SA_SIGINFO;
    segvAction.sa_sigaction = s2e_ext_sigsegv_handler;
    sigaction(SIGSEGV, &segvAction, &segvActionOld);

    memcpy(s2e_cpuExitJmpBuf, env->jmp_env, sizeof(env->jmp_env));

    if (setjmp(env->jmp_env)) {
        memcpy(env->jmp_env, s2e_cpuExitJmpBuf, sizeof(env->jmp_env));
        throw CpuExitException();
    } else {
        if (setjmp(s2e_escapeCallJmpBuf)) {
            res = false;
        } else {
            std::vector<GenericValue> gvArgs;
            ExecutionEngine *ee = getExecutionEngine(f);

            ee->runFunction(f, gvArgs);
            res = true;
        }
    }

    memcpy(env->jmp_env, s2e_cpuExitJmpBuf, sizeof(env->jmp_env));

    sigaction(SIGSEGV, &segvActionOld, 0);
    return res;
}

/**
 * Remove all mappings between calls to external functions
 * and the actual external call stub generated by KLEE.
 * Also remove the machine code for the stub and the stub itself.
 * This is used whenever S2E deletes a translation block and its LLVM
 * representation. Failing to do so would leave stale references to
 * machine code in KLEE's external dispatcher.
 */
void S2EExternalDispatcher::removeFunction(llvm::Function *f) {
    dispatchers_ty::iterator it, itn;

    it = dispatchers.begin();
    while (it != dispatchers.end()) {
        if ((*it).first->getParent()->getParent() == f) {

            llvm::Function *dispatcher = (*it).second;
            dispatcher->eraseFromParent();

            itn = it;
            ++itn;
            dispatchers.erase(it);
            it = itn;
        } else {
            ++it;
        }
    }
}
}
