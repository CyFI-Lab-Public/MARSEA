///
/// Copyright (C) 2018, Cyberhaven
/// All rights reserved.
///
/// Licensed under the Cyberhaven Research License Agreement.
///

#include <zlib.h>

#include <s2e/S2EExecutionState.h>

#include "PovGenerator.h"

namespace s2e {
namespace plugins {
namespace pov {

using namespace klee;

///
/// \brief PovGenerator::writeToFile save a PoV to a file.
/// PoV submission has to be carried out in a separate plugin.
///
/// \return the file name
///
std::string PovGenerator::writeToFile(S2EExecutionState *state, const PovOptions &opt, const std::string &filePrefix,
                                      const std::string &fileExtWithoutDot, const std::string &pov) {
    std::vector<uint8_t> contents;
    if (m_compress) {
        contents = compress(pov);
    } else {
        contents.insert(contents.end(), pov.begin(), pov.end());
    }

    std::stringstream povFileNameSS;

    if (filePrefix.length() > 0) {
        povFileNameSS << filePrefix << "-";
    }

    switch (opt.m_type) {
        case POV_TYPE1:
            povFileNameSS << "pov-type1-";
            break;
        case POV_TYPE2:
            povFileNameSS << "pov-type2-";
            break;
        default:
            povFileNameSS << "pov-unknown-";
            break;
    }

    povFileNameSS << state->getID() << "." << fileExtWithoutDot;
    if (m_compress) {
        povFileNameSS << ".zlib"; // use `zlib-flate -uncompress`
    }

    std::string povFileName = g_s2e->getOutputFilename(povFileNameSS.str());

    FILE *povFile = fopen(povFileName.c_str(), "wb");

    if (!povFile) {
        g_s2e->getWarningsStream(state) << "Could not create POV file" << '\n';
        exit(-1);
    }

    if (fwrite(&contents[0], 1, contents.size(), povFile) != contents.size()) {
        int err = errno;
        g_s2e->getWarningsStream(state) << "Could not write POV file (" << strerror(err) << ")\n";
        exit(-1);
    }

    if (fclose(povFile) != 0) {
        g_s2e->getWarningsStream(state) << "Error closing POV file" << '\n';
        exit(-1);
    }

    g_s2e->getInfoStream(state) << "POV saved to file " << povFileName << "\n";

    return povFileName;
}

/* http://stackoverflow.com/questions/4538586/how-to-compress-a-buffer-with-zlib */
void PovGenerator::compress(void *in_data, size_t in_data_size, std::vector<uint8_t> &out_data) {
    std::vector<uint8_t> buffer;

    const size_t BUFSIZE = 128 * 1024;
    uint8_t temp_buffer[BUFSIZE];

    z_stream strm;
    strm.zalloc = 0;
    strm.zfree = 0;
    strm.next_in = reinterpret_cast<uint8_t *>(in_data);
    strm.avail_in = in_data_size;
    strm.next_out = temp_buffer;
    strm.avail_out = BUFSIZE;

    deflateInit(&strm, Z_BEST_COMPRESSION);

    while (strm.avail_in != 0) {
        int res = deflate(&strm, Z_NO_FLUSH);
        s2e_assert(NULL, res == Z_OK, "Deflate error");
        if (strm.avail_out == 0) {
            buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE);
            strm.next_out = temp_buffer;
            strm.avail_out = BUFSIZE;
        }
    }

    int deflate_res = Z_OK;
    while (deflate_res == Z_OK) {
        if (strm.avail_out == 0) {
            buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE);
            strm.next_out = temp_buffer;
            strm.avail_out = BUFSIZE;
        }
        deflate_res = deflate(&strm, Z_FINISH);
    }

    s2e_assert(NULL, deflate_res == Z_STREAM_END, "Deflate error");
    buffer.insert(buffer.end(), temp_buffer, temp_buffer + BUFSIZE - strm.avail_out);
    deflateEnd(&strm);

    out_data.swap(buffer);
}

std::vector<uint8_t> PovGenerator::compress(const std::string &s) {
    std::vector<uint8_t> compressed;
    compress((void *) s.c_str(), s.size(), compressed);
    return compressed;
}

bool PovGenerator::solveConstraints(S2EExecutionState *state, const PovOptions &opt, Assignment &assignment) {
    using namespace klee;

    if (opt.m_extraConstraints.size() > 0) {
        ConstraintManager constraints = state->constraints;
        for (auto it : opt.m_extraConstraints) {
            constraints.addConstraint(it);
        }

        // TODO: all this constraints to assignment could be moved to klee
        // TODO: try to preserve existing concolics as much as possible

        // Extract symbolic objects
        std::vector<const Array *> symbObjects;
        for (unsigned i = 0; i < state->symbolics.size(); ++i) {
            symbObjects.push_back(state->symbolics[i].second);
        }

        std::vector<std::vector<unsigned char>> concreteObjects;

        // XXX: Not sure about passing state, we may have new constraints
        Solver *solver = s2e()->getExecutor()->getSolver(*state);
        Query query(constraints, ConstantExpr::alloc(0, Expr::Bool));
        if (!solver->getInitialValues(query, symbObjects, concreteObjects)) {
            getWarningsStream() << "Could not get symbolic solution\n";
            return false;
        }

        for (unsigned i = 0; i < symbObjects.size(); ++i) {
            assignment.add(symbObjects[i], concreteObjects[i]);
        }
    } else {
        assignment = *state->concolics;
    }

    return true;
}
}
}
}
